// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/ragt2ridges.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// armaRidgePAnyTarget
arma::mat armaRidgePAnyTarget(const arma::mat& S, const arma::mat& target, const double lambda, int invert);
RcppExport SEXP ragt2ridges_armaRidgePAnyTarget(SEXP SSEXP, SEXP targetSEXP, SEXP lambdaSEXP, SEXP invertSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type S(SSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type target(targetSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< int >::type invert(invertSEXP);
    rcpp_result_gen = Rcpp::wrap(armaRidgePAnyTarget(S, target, lambda, invert));
    return rcpp_result_gen;
END_RCPP
}
// armaRidgePScalarTarget
arma::mat armaRidgePScalarTarget(const arma::mat& S, const double alpha, const double lambda, int invert);
RcppExport SEXP ragt2ridges_armaRidgePScalarTarget(SEXP SSEXP, SEXP alphaSEXP, SEXP lambdaSEXP, SEXP invertSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type S(SSEXP);
    Rcpp::traits::input_parameter< const double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< int >::type invert(invertSEXP);
    rcpp_result_gen = Rcpp::wrap(armaRidgePScalarTarget(S, alpha, lambda, invert));
    return rcpp_result_gen;
END_RCPP
}
// armaRidgeP
arma::mat armaRidgeP(const arma::mat& S, const arma::mat& target, const double lambda, int invert);
RcppExport SEXP ragt2ridges_armaRidgeP(SEXP SSEXP, SEXP targetSEXP, SEXP lambdaSEXP, SEXP invertSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type S(SSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type target(targetSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< int >::type invert(invertSEXP);
    rcpp_result_gen = Rcpp::wrap(armaRidgeP(S, target, lambda, invert));
    return rcpp_result_gen;
END_RCPP
}
// armaVAR1_ridgeML
Rcpp::List armaVAR1_ridgeML(Rcpp::NumericVector& Yraw, const double lambdaA, const double lambdaP, arma::mat& targetA, arma::mat& targetP, std::string targetPtype, std::string fitA, arma::mat& unbalanced, bool diagP, bool efficient, const int nInit, const double minSuccDiff);
static SEXP ragt2ridges_armaVAR1_ridgeML_try(SEXP YrawSEXP, SEXP lambdaASEXP, SEXP lambdaPSEXP, SEXP targetASEXP, SEXP targetPSEXP, SEXP targetPtypeSEXP, SEXP fitASEXP, SEXP unbalancedSEXP, SEXP diagPSEXP, SEXP efficientSEXP, SEXP nInitSEXP, SEXP minSuccDiffSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    Rcpp::traits::input_parameter< const double >::type lambdaA(lambdaASEXP);
    Rcpp::traits::input_parameter< const double >::type lambdaP(lambdaPSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type targetA(targetASEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type targetP(targetPSEXP);
    Rcpp::traits::input_parameter< std::string >::type targetPtype(targetPtypeSEXP);
    Rcpp::traits::input_parameter< std::string >::type fitA(fitASEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type unbalanced(unbalancedSEXP);
    Rcpp::traits::input_parameter< bool >::type diagP(diagPSEXP);
    Rcpp::traits::input_parameter< bool >::type efficient(efficientSEXP);
    Rcpp::traits::input_parameter< const int >::type nInit(nInitSEXP);
    Rcpp::traits::input_parameter< const double >::type minSuccDiff(minSuccDiffSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_ridgeML(Yraw, lambdaA, lambdaP, targetA, targetP, targetPtype, fitA, unbalanced, diagP, efficient, nInit, minSuccDiff));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_ridgeML(SEXP YrawSEXP, SEXP lambdaASEXP, SEXP lambdaPSEXP, SEXP targetASEXP, SEXP targetPSEXP, SEXP targetPtypeSEXP, SEXP fitASEXP, SEXP unbalancedSEXP, SEXP diagPSEXP, SEXP efficientSEXP, SEXP nInitSEXP, SEXP minSuccDiffSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_ridgeML_try(YrawSEXP, lambdaASEXP, lambdaPSEXP, targetASEXP, targetPSEXP, targetPtypeSEXP, fitASEXP, unbalancedSEXP, diagPSEXP, efficientSEXP, nInitSEXP, minSuccDiffSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_ridgeML_zerosA
Rcpp::List armaVAR1_ridgeML_zerosA(Rcpp::NumericVector& Yraw, const double lambdaA, const double lambdaP, arma::mat& targetA, arma::mat& targetP, std::string targetPtype, std::string fitA, arma::mat unbalanced, bool diagP, bool efficient, const int nInit, const double minSuccDiff, const arma::uvec& zerosR, const arma::uvec& zerosC, std::string zerosAfit);
static SEXP ragt2ridges_armaVAR1_ridgeML_zerosA_try(SEXP YrawSEXP, SEXP lambdaASEXP, SEXP lambdaPSEXP, SEXP targetASEXP, SEXP targetPSEXP, SEXP targetPtypeSEXP, SEXP fitASEXP, SEXP unbalancedSEXP, SEXP diagPSEXP, SEXP efficientSEXP, SEXP nInitSEXP, SEXP minSuccDiffSEXP, SEXP zerosRSEXP, SEXP zerosCSEXP, SEXP zerosAfitSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    Rcpp::traits::input_parameter< const double >::type lambdaA(lambdaASEXP);
    Rcpp::traits::input_parameter< const double >::type lambdaP(lambdaPSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type targetA(targetASEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type targetP(targetPSEXP);
    Rcpp::traits::input_parameter< std::string >::type targetPtype(targetPtypeSEXP);
    Rcpp::traits::input_parameter< std::string >::type fitA(fitASEXP);
    Rcpp::traits::input_parameter< arma::mat >::type unbalanced(unbalancedSEXP);
    Rcpp::traits::input_parameter< bool >::type diagP(diagPSEXP);
    Rcpp::traits::input_parameter< bool >::type efficient(efficientSEXP);
    Rcpp::traits::input_parameter< const int >::type nInit(nInitSEXP);
    Rcpp::traits::input_parameter< const double >::type minSuccDiff(minSuccDiffSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type zerosR(zerosRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type zerosC(zerosCSEXP);
    Rcpp::traits::input_parameter< std::string >::type zerosAfit(zerosAfitSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_ridgeML_zerosA(Yraw, lambdaA, lambdaP, targetA, targetP, targetPtype, fitA, unbalanced, diagP, efficient, nInit, minSuccDiff, zerosR, zerosC, zerosAfit));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_ridgeML_zerosA(SEXP YrawSEXP, SEXP lambdaASEXP, SEXP lambdaPSEXP, SEXP targetASEXP, SEXP targetPSEXP, SEXP targetPtypeSEXP, SEXP fitASEXP, SEXP unbalancedSEXP, SEXP diagPSEXP, SEXP efficientSEXP, SEXP nInitSEXP, SEXP minSuccDiffSEXP, SEXP zerosRSEXP, SEXP zerosCSEXP, SEXP zerosAfitSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_ridgeML_zerosA_try(YrawSEXP, lambdaASEXP, lambdaPSEXP, targetASEXP, targetPSEXP, targetPtypeSEXP, fitASEXP, unbalancedSEXP, diagPSEXP, efficientSEXP, nInitSEXP, minSuccDiffSEXP, zerosRSEXP, zerosCSEXP, zerosAfitSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaEigenDecomp_blockDiagOnly_forR
Rcpp::List armaEigenDecomp_blockDiagOnly_forR(const arma::mat symMat, const arma::ivec blockDims);
static SEXP ragt2ridges_armaEigenDecomp_blockDiagOnly_forR_try(SEXP symMatSEXP, SEXP blockDimsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type symMat(symMatSEXP);
    Rcpp::traits::input_parameter< const arma::ivec >::type blockDims(blockDimsSEXP);
    rcpp_result_gen = Rcpp::wrap(armaEigenDecomp_blockDiagOnly_forR(symMat, blockDims));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaEigenDecomp_blockDiagOnly_forR(SEXP symMatSEXP, SEXP blockDimsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaEigenDecomp_blockDiagOnly_forR_try(symMatSEXP, blockDimsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_Shat_ML_forR
arma::mat armaVAR1_Shat_ML_forR(Rcpp::NumericVector& Yraw, const arma::mat& A);
static SEXP ragt2ridges_armaVAR1_Shat_ML_forR_try(SEXP YrawSEXP, SEXP ASEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type A(ASEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_Shat_ML_forR(Yraw, A));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_Shat_ML_forR(SEXP YrawSEXP, SEXP ASEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_Shat_ML_forR_try(YrawSEXP, ASEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_COVYhat_forR
arma::mat armaVAR1_COVYhat_forR(Rcpp::NumericVector& Yraw);
static SEXP ragt2ridges_armaVAR1_COVYhat_forR_try(SEXP YrawSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_COVYhat_forR(Yraw));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_COVYhat_forR(SEXP YrawSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_COVYhat_forR_try(YrawSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_VARYhat_forR
arma::mat armaVAR1_VARYhat_forR(Rcpp::NumericVector& Yraw, bool efficient, arma::mat unbalanced);
static SEXP ragt2ridges_armaVAR1_VARYhat_forR_try(SEXP YrawSEXP, SEXP efficientSEXP, SEXP unbalancedSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    Rcpp::traits::input_parameter< bool >::type efficient(efficientSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type unbalanced(unbalancedSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_VARYhat_forR(Yraw, efficient, unbalanced));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_VARYhat_forR(SEXP YrawSEXP, SEXP efficientSEXP, SEXP unbalancedSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_VARYhat_forR_try(YrawSEXP, efficientSEXP, unbalancedSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_Ahat_zeros_forR
arma::mat armaVAR1_Ahat_zeros_forR(const arma::mat& P, arma::mat& COVY, const arma::mat& eigvecVARY, const arma::vec eigvalVARY, const double lambdaA, const arma::mat& targetA, std::string fitA, const arma::uvec& zerosR, const arma::uvec& zerosC, std::string zerosAfit);
static SEXP ragt2ridges_armaVAR1_Ahat_zeros_forR_try(SEXP PSEXP, SEXP COVYSEXP, SEXP eigvecVARYSEXP, SEXP eigvalVARYSEXP, SEXP lambdaASEXP, SEXP targetASEXP, SEXP fitASEXP, SEXP zerosRSEXP, SEXP zerosCSEXP, SEXP zerosAfitSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type P(PSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type COVY(COVYSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type eigvecVARY(eigvecVARYSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type eigvalVARY(eigvalVARYSEXP);
    Rcpp::traits::input_parameter< const double >::type lambdaA(lambdaASEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type targetA(targetASEXP);
    Rcpp::traits::input_parameter< std::string >::type fitA(fitASEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type zerosR(zerosRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec& >::type zerosC(zerosCSEXP);
    Rcpp::traits::input_parameter< std::string >::type zerosAfit(zerosAfitSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_Ahat_zeros_forR(P, COVY, eigvecVARY, eigvalVARY, lambdaA, targetA, fitA, zerosR, zerosC, zerosAfit));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_Ahat_zeros_forR(SEXP PSEXP, SEXP COVYSEXP, SEXP eigvecVARYSEXP, SEXP eigvalVARYSEXP, SEXP lambdaASEXP, SEXP targetASEXP, SEXP fitASEXP, SEXP zerosRSEXP, SEXP zerosCSEXP, SEXP zerosAfitSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_Ahat_zeros_forR_try(PSEXP, COVYSEXP, eigvecVARYSEXP, eigvalVARYSEXP, lambdaASEXP, targetASEXP, fitASEXP, zerosRSEXP, zerosCSEXP, zerosAfitSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaP_defaultTarget_forR
arma::mat armaP_defaultTarget_forR(arma::mat S, std::string targetType, const double fraction, double const multiplier);
static SEXP ragt2ridges_armaP_defaultTarget_forR_try(SEXP SSEXP, SEXP targetTypeSEXP, SEXP fractionSEXP, SEXP multiplierSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat >::type S(SSEXP);
    Rcpp::traits::input_parameter< std::string >::type targetType(targetTypeSEXP);
    Rcpp::traits::input_parameter< const double >::type fraction(fractionSEXP);
    Rcpp::traits::input_parameter< double const >::type multiplier(multiplierSEXP);
    rcpp_result_gen = Rcpp::wrap(armaP_defaultTarget_forR(S, targetType, fraction, multiplier));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaP_defaultTarget_forR(SEXP SSEXP, SEXP targetTypeSEXP, SEXP fractionSEXP, SEXP multiplierSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaP_defaultTarget_forR_try(SSEXP, targetTypeSEXP, fractionSEXP, multiplierSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR_array2cube_withMissing_forR
arma::cube armaVAR_array2cube_withMissing_forR(Rcpp::NumericVector& Yraw, const arma::uvec unbalancedR, const arma::uvec unbalancedC);
static SEXP ragt2ridges_armaVAR_array2cube_withMissing_forR_try(SEXP YrawSEXP, SEXP unbalancedRSEXP, SEXP unbalancedCSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type unbalancedR(unbalancedRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type unbalancedC(unbalancedCSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR_array2cube_withMissing_forR(Yraw, unbalancedR, unbalancedC));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR_array2cube_withMissing_forR(SEXP YrawSEXP, SEXP unbalancedRSEXP, SEXP unbalancedCSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR_array2cube_withMissing_forR_try(YrawSEXP, unbalancedRSEXP, unbalancedCSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR_array2cube_withoutMissing_forR
arma::cube armaVAR_array2cube_withoutMissing_forR(Rcpp::NumericVector& Yraw);
static SEXP ragt2ridges_armaVAR_array2cube_withoutMissing_forR_try(SEXP YrawSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR_array2cube_withoutMissing_forR(Yraw));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR_array2cube_withoutMissing_forR(SEXP YrawSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR_array2cube_withoutMissing_forR_try(YrawSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaEigenDecomp_forR
Rcpp::List armaEigenDecomp_forR(const arma::mat symMat);
static SEXP ragt2ridges_armaEigenDecomp_forR_try(SEXP symMatSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat >::type symMat(symMatSEXP);
    rcpp_result_gen = Rcpp::wrap(armaEigenDecomp_forR(symMat));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaEigenDecomp_forR(SEXP symMatSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaEigenDecomp_forR_try(symMatSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_convergenceEvaluation_forR
double armaVAR1_convergenceEvaluation_forR(arma::mat& Ahat, arma::mat& Aprev, arma::mat& Phat, arma::mat& Pprev);
static SEXP ragt2ridges_armaVAR1_convergenceEvaluation_forR_try(SEXP AhatSEXP, SEXP AprevSEXP, SEXP PhatSEXP, SEXP PprevSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat& >::type Ahat(AhatSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type Aprev(AprevSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type Phat(PhatSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type Pprev(PprevSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_convergenceEvaluation_forR(Ahat, Aprev, Phat, Pprev));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_convergenceEvaluation_forR(SEXP AhatSEXP, SEXP AprevSEXP, SEXP PhatSEXP, SEXP PprevSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_convergenceEvaluation_forR_try(AhatSEXP, AprevSEXP, PhatSEXP, PprevSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_Ahat_ridgeML_forR
arma::mat armaVAR1_Ahat_ridgeML_forR(arma::mat& P, arma::mat& COVY, const arma::mat& eigvecVARY, const arma::colvec eigvalVARY, const double lambdaA, arma::mat& targetA);
static SEXP ragt2ridges_armaVAR1_Ahat_ridgeML_forR_try(SEXP PSEXP, SEXP COVYSEXP, SEXP eigvecVARYSEXP, SEXP eigvalVARYSEXP, SEXP lambdaASEXP, SEXP targetASEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat& >::type P(PSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type COVY(COVYSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type eigvecVARY(eigvecVARYSEXP);
    Rcpp::traits::input_parameter< const arma::colvec >::type eigvalVARY(eigvalVARYSEXP);
    Rcpp::traits::input_parameter< const double >::type lambdaA(lambdaASEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type targetA(targetASEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_Ahat_ridgeML_forR(P, COVY, eigvecVARY, eigvalVARY, lambdaA, targetA));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_Ahat_ridgeML_forR(SEXP PSEXP, SEXP COVYSEXP, SEXP eigvecVARYSEXP, SEXP eigvalVARYSEXP, SEXP lambdaASEXP, SEXP targetASEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_Ahat_ridgeML_forR_try(PSEXP, COVYSEXP, eigvecVARYSEXP, eigvalVARYSEXP, lambdaASEXP, targetASEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_Ahat_ridgeSS_forR
arma::mat armaVAR1_Ahat_ridgeSS_forR(arma::mat& VARY, arma::mat& COVY, const double& lambdaA, arma::mat& targetA);
static SEXP ragt2ridges_armaVAR1_Ahat_ridgeSS_forR_try(SEXP VARYSEXP, SEXP COVYSEXP, SEXP lambdaASEXP, SEXP targetASEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::mat& >::type VARY(VARYSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type COVY(COVYSEXP);
    Rcpp::traits::input_parameter< const double& >::type lambdaA(lambdaASEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type targetA(targetASEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_Ahat_ridgeSS_forR(VARY, COVY, lambdaA, targetA));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_Ahat_ridgeSS_forR(SEXP VARYSEXP, SEXP COVYSEXP, SEXP lambdaASEXP, SEXP targetASEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_Ahat_ridgeSS_forR_try(VARYSEXP, COVYSEXP, lambdaASEXP, targetASEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_loglikLOOCVinternal_forR
double armaVAR1_loglikLOOCVinternal_forR(arma::vec Yt1, arma::vec Yt0, arma::mat& A, arma::mat& P);
static SEXP ragt2ridges_armaVAR1_loglikLOOCVinternal_forR_try(SEXP Yt1SEXP, SEXP Yt0SEXP, SEXP ASEXP, SEXP PSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< arma::vec >::type Yt1(Yt1SEXP);
    Rcpp::traits::input_parameter< arma::vec >::type Yt0(Yt0SEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type A(ASEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type P(PSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_loglikLOOCVinternal_forR(Yt1, Yt0, A, P));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_loglikLOOCVinternal_forR(SEXP Yt1SEXP, SEXP Yt0SEXP, SEXP ASEXP, SEXP PSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_loglikLOOCVinternal_forR_try(Yt1SEXP, Yt0SEXP, ASEXP, PSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaVAR1_loglik_forR
double armaVAR1_loglik_forR(Rcpp::NumericVector& Yraw, arma::mat& A, arma::mat& P);
static SEXP ragt2ridges_armaVAR1_loglik_forR_try(SEXP YrawSEXP, SEXP ASEXP, SEXP PSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::NumericVector& >::type Yraw(YrawSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type A(ASEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type P(PSEXP);
    rcpp_result_gen = Rcpp::wrap(armaVAR1_loglik_forR(Yraw, A, P));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP ragt2ridges_armaVAR1_loglik_forR(SEXP YrawSEXP, SEXP ASEXP, SEXP PSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(ragt2ridges_armaVAR1_loglik_forR_try(YrawSEXP, ASEXP, PSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// armaRidgePchordalInitWorkhorse
arma::mat armaRidgePchordalInitWorkhorse(arma::mat S, const double lambda, arma::mat target, std::string type, Rcpp::List Cliques, Rcpp::List Separators);
RcppExport SEXP ragt2ridges_armaRidgePchordalInitWorkhorse(SEXP SSEXP, SEXP lambdaSEXP, SEXP targetSEXP, SEXP typeSEXP, SEXP CliquesSEXP, SEXP SeparatorsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat >::type S(SSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type target(targetSEXP);
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type Cliques(CliquesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type Separators(SeparatorsSEXP);
    rcpp_result_gen = Rcpp::wrap(armaRidgePchordalInitWorkhorse(S, lambda, target, type, Cliques, Separators));
    return rcpp_result_gen;
END_RCPP
}
// armaPenLLreparPforNLM
Rcpp::NumericVector armaPenLLreparPforNLM(const arma::vec x, const arma::mat E1, const arma::mat E2, const arma::mat S, const double lambda, const arma::mat target, const arma::uvec nonzerosR, const arma::uvec nonzerosC);
RcppExport SEXP ragt2ridges_armaPenLLreparPforNLM(SEXP xSEXP, SEXP E1SEXP, SEXP E2SEXP, SEXP SSEXP, SEXP lambdaSEXP, SEXP targetSEXP, SEXP nonzerosRSEXP, SEXP nonzerosCSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E1(E1SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E2(E2SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type S(SSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type target(targetSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosR(nonzerosRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosC(nonzerosCSEXP);
    rcpp_result_gen = Rcpp::wrap(armaPenLLreparPforNLM(x, E1, E2, S, lambda, target, nonzerosR, nonzerosC));
    return rcpp_result_gen;
END_RCPP
}
// armaPenLLreparP
double armaPenLLreparP(const arma::vec x, const arma::mat E1, const arma::mat E2, const arma::mat S, const double lambda, const arma::mat target, const arma::uvec nonzerosR, const arma::uvec nonzerosC);
RcppExport SEXP ragt2ridges_armaPenLLreparP(SEXP xSEXP, SEXP E1SEXP, SEXP E2SEXP, SEXP SSEXP, SEXP lambdaSEXP, SEXP targetSEXP, SEXP nonzerosRSEXP, SEXP nonzerosCSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E1(E1SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E2(E2SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type S(SSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type target(targetSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosR(nonzerosRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosC(nonzerosCSEXP);
    rcpp_result_gen = Rcpp::wrap(armaPenLLreparP(x, E1, E2, S, lambda, target, nonzerosR, nonzerosC));
    return rcpp_result_gen;
END_RCPP
}
// armaPenLLreparPgrad
arma::vec armaPenLLreparPgrad(const arma::vec x, const arma::mat E1, const arma::mat E2, const arma::mat S, const double lambda, const arma::mat target, const arma::uvec nonzerosR, const arma::uvec nonzerosC);
RcppExport SEXP ragt2ridges_armaPenLLreparPgrad(SEXP xSEXP, SEXP E1SEXP, SEXP E2SEXP, SEXP SSEXP, SEXP lambdaSEXP, SEXP targetSEXP, SEXP nonzerosRSEXP, SEXP nonzerosCSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E1(E1SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E2(E2SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type S(SSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type target(targetSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosR(nonzerosRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosC(nonzerosCSEXP);
    rcpp_result_gen = Rcpp::wrap(armaPenLLreparPgrad(x, E1, E2, S, lambda, target, nonzerosR, nonzerosC));
    return rcpp_result_gen;
END_RCPP
}
// armaPenLLreparGradArchI
arma::vec armaPenLLreparGradArchI(const arma::vec x, const arma::mat E1, const arma::mat E2, const arma::mat S, const double lambda, const arma::mat target, const arma::uvec nonzerosR, const arma::uvec nonzerosC);
RcppExport SEXP ragt2ridges_armaPenLLreparGradArchI(SEXP xSEXP, SEXP E1SEXP, SEXP E2SEXP, SEXP SSEXP, SEXP lambdaSEXP, SEXP targetSEXP, SEXP nonzerosRSEXP, SEXP nonzerosCSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E1(E1SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E2(E2SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type S(SSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type target(targetSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosR(nonzerosRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosC(nonzerosCSEXP);
    rcpp_result_gen = Rcpp::wrap(armaPenLLreparGradArchI(x, E1, E2, S, lambda, target, nonzerosR, nonzerosC));
    return rcpp_result_gen;
END_RCPP
}
// armaPenLLreparGradArchII
arma::vec armaPenLLreparGradArchII(const arma::vec x, const arma::mat E1, const arma::mat E2, const arma::mat S, const double lambda, const arma::mat target, const arma::uvec nonzerosR, const arma::uvec nonzerosC);
RcppExport SEXP ragt2ridges_armaPenLLreparGradArchII(SEXP xSEXP, SEXP E1SEXP, SEXP E2SEXP, SEXP SSEXP, SEXP lambdaSEXP, SEXP targetSEXP, SEXP nonzerosRSEXP, SEXP nonzerosCSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::vec >::type x(xSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E1(E1SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type E2(E2SEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type S(SSEXP);
    Rcpp::traits::input_parameter< const double >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< const arma::mat >::type target(targetSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosR(nonzerosRSEXP);
    Rcpp::traits::input_parameter< const arma::uvec >::type nonzerosC(nonzerosCSEXP);
    rcpp_result_gen = Rcpp::wrap(armaPenLLreparGradArchII(x, E1, E2, S, lambda, target, nonzerosR, nonzerosC));
    return rcpp_result_gen;
END_RCPP
}

// validate (ensure exported C++ functions exist before calling them)
static int ragt2ridges_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("Rcpp::List(*.armaVAR1_ridgeML)(Rcpp::NumericVector&,const double,const double,arma::mat&,arma::mat&,std::string,std::string,arma::mat&,bool,bool,const int,const double)");
        signatures.insert("Rcpp::List(*.armaVAR1_ridgeML_zerosA)(Rcpp::NumericVector&,const double,const double,arma::mat&,arma::mat&,std::string,std::string,arma::mat,bool,bool,const int,const double,const arma::uvec&,const arma::uvec&,std::string)");
        signatures.insert("Rcpp::List(*.armaEigenDecomp_blockDiagOnly)(const arma::mat,const arma::ivec)");
        signatures.insert("arma::mat(*.armaVAR1_Shat_ML)(Rcpp::NumericVector&,const arma::mat&)");
        signatures.insert("arma::mat(*.armaVAR1_COVYhat)(Rcpp::NumericVector&)");
        signatures.insert("arma::mat(*.armaVAR1_VARYhat)(Rcpp::NumericVector&,bool,arma::mat)");
        signatures.insert("arma::mat(*.armaVAR1_Ahat_zeros)(const arma::mat&,arma::mat&,const arma::mat&,const arma::vec,const double,const arma::mat&,std::string,const arma::uvec&,const arma::uvec&,std::string)");
        signatures.insert("arma::mat(*.armaP_defaultTarget)(arma::mat,std::string,const double,double const)");
        signatures.insert("arma::cube(*.armaVAR_array2cube_withMissing)(Rcpp::NumericVector&,const arma::uvec,const arma::uvec)");
        signatures.insert("arma::cube(*.armaVAR_array2cube_withoutMissing)(Rcpp::NumericVector&)");
        signatures.insert("Rcpp::List(*.armaEigenDecomp)(const arma::mat)");
        signatures.insert("double(*.armaVAR1_convergenceEvaluation)(arma::mat&,arma::mat&,arma::mat&,arma::mat&)");
        signatures.insert("arma::mat(*.armaVAR1_Ahat_ridgeML)(arma::mat&,arma::mat&,const arma::mat&,const arma::colvec,const double,arma::mat&)");
        signatures.insert("arma::mat(*.armaVAR1_Ahat_ridgeSS)(arma::mat&,arma::mat&,const double&,arma::mat&)");
        signatures.insert("double(*.armaVAR1_loglik_LOOCVinternal)(arma::vec,arma::vec,arma::mat&,arma::mat&)");
        signatures.insert("double(*.armaVAR1_loglik)(Rcpp::NumericVector&,arma::mat&,arma::mat&)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP ragt2ridges_RcppExport_registerCCallable() { 
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_ridgeML", (DL_FUNC)ragt2ridges_armaVAR1_ridgeML_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_ridgeML_zerosA", (DL_FUNC)ragt2ridges_armaVAR1_ridgeML_zerosA_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaEigenDecomp_blockDiagOnly", (DL_FUNC)ragt2ridges_armaEigenDecomp_blockDiagOnly_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_Shat_ML", (DL_FUNC)ragt2ridges_armaVAR1_Shat_ML_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_COVYhat", (DL_FUNC)ragt2ridges_armaVAR1_COVYhat_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_VARYhat", (DL_FUNC)ragt2ridges_armaVAR1_VARYhat_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_Ahat_zeros", (DL_FUNC)ragt2ridges_armaVAR1_Ahat_zeros_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaP_defaultTarget", (DL_FUNC)ragt2ridges_armaP_defaultTarget_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR_array2cube_withMissing", (DL_FUNC)ragt2ridges_armaVAR_array2cube_withMissing_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR_array2cube_withoutMissing", (DL_FUNC)ragt2ridges_armaVAR_array2cube_withoutMissing_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaEigenDecomp", (DL_FUNC)ragt2ridges_armaEigenDecomp_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_convergenceEvaluation", (DL_FUNC)ragt2ridges_armaVAR1_convergenceEvaluation_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_Ahat_ridgeML", (DL_FUNC)ragt2ridges_armaVAR1_Ahat_ridgeML_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_Ahat_ridgeSS", (DL_FUNC)ragt2ridges_armaVAR1_Ahat_ridgeSS_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_loglik_LOOCVinternal", (DL_FUNC)ragt2ridges_armaVAR1_loglikLOOCVinternal_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_.armaVAR1_loglik", (DL_FUNC)ragt2ridges_armaVAR1_loglik_forR_try);
    R_RegisterCCallable("ragt2ridges", "ragt2ridges_RcppExport_validate", (DL_FUNC)ragt2ridges_RcppExport_validate);
    return R_NilValue;
}
